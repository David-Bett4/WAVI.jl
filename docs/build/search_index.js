var documenterSearchIndex = {"docs":
[{"location":"references.html","page":"References","title":"References","text":"","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"EditURL = \"<unknown>/examples/bumpy_bed.jl\"","category":"page"},{"location":"generated/bumpy_bed.html#Ice-Flow-over-a-Bumpy-Bed","page":"Flow over a bumpy bed","title":"Ice Flow over a Bumpy Bed","text":"","category":"section"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"This is the first two dimensional example: flow down a plane with bumps with different length scales. This example is similar in spirit to Experiment A in the Ice Sheet Model Intercomparison Exercise - Higher Order Model (ISMIP-HOM): doi: 10.5194/tc-2-95-2008 This example demonstrates: How to use WAVI.jl in plan view (two horizontal spatial dimensions) with arbitrary bed shapes, and how to interact with Grid objects.","category":"page"},{"location":"generated/bumpy_bed.html#Install-dependencies","page":"Flow over a bumpy bed","title":"Install dependencies","text":"","category":"section"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"using Pkg\npkg\"add WAVI, Plots\"","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"using WAVI, Plots","category":"page"},{"location":"generated/bumpy_bed.html#Basal-Topography","page":"Flow over a bumpy bed","title":"Basal Topography","text":"","category":"section"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"Following ISMIP-HOM, let's take a bed with a series of sinusoidal oscillations with an amplitude of 500m: $ z_b(x,y) = -x \\tan \\alpha + 500 \\sin (\\omega x) \\sin(\\omega y) $ Here L is the lengthscale of the domain, alpha is the net slope of the plane, and omega = 2pi  L is the frequency of the bumps. Let's define this bed as a function and take a look at it:","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"z_b(x,y; α, ω) = -x * tand(α) + 500sin(ω*x)*sin(ω*y);\nnothing #hide","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"It's useful to define our model grid here. We can do this for an arbitary domain length L.","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"grid(; L, nx = 80,ny = 80) = Grid(nx = nx, ny = ny, dx = L/nx, dy = L/ny, y0 = 0.0, x0 = 0.0);\nnothing #hide","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"The final two arguments simply set the origin of the co-ordinate system. This grid has 80 grid points in each direction by default","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"Let's choose a domain of 80km with 80 grid points","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"L = 80000.;\ngrid80 = grid(L = L);\nnothing #hide","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"This grid object contains information about the location of grid points. We use this to construct and array defining the bed:","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"z_b80 = z_b.(grid80.xxh,grid80.yyh; α = 0.5, ω = 2π/L );\nplt = Plots.heatmap(grid80.xxh[:,1]/1e3, grid80.yyh[1,:]/1e3, z_b80,\n                        xlabel = \"x (km)\",\n                        ylabel = \"y (km)\",\n                        colorbar_title = \"bed depth (m)\")\nplot!(size = (800,400))\n#display(plt)","category":"page"},{"location":"generated/bumpy_bed.html#Model-Instantiation-and-Initial-Conditions","page":"Flow over a bumpy bed","title":"Model Instantiation and Initial Conditions","text":"","category":"section"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"In the ISMIP-HOM comparison, the main test is velocity along the line y = L4, for various different values of L. Before we do that, lets look at the velocity for the example we started above with L = 80km.","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"To begin, we create an InitialConditions object to prescribe the ice thickness of 1000m everywhere","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"initial_conditions = InitialConditions(initial_thickness = 1000. .* ones(grid80.nx, grid80.ny));\nnothing #hide","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"Now we can build our model","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"model80 = Model(grid = grid80,\n            bed_elevation = z_b80,\n            initial_conditions = initial_conditions);\nnothing #hide","category":"page"},{"location":"generated/bumpy_bed.html#Determining-the-velocity","page":"Flow over a bumpy bed","title":"Determining the velocity","text":"","category":"section"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"To bring the velocity in line with the ice thickness, we have to use the update_state! function","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"update_state!(model80);\nnothing #hide","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"Let's have a look at the velocity component in the x-direction","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"Plots.heatmap(model80.grid.xxh[:,1]/1e3, model80.grid.yyh[1,:]/1e3, model80.fields.gh.u',\n                        xlabel = \"x (km)\",\n                        ylabel = \"y (km)\",\n                        colorbar_title = \"ice velocity in x-direction (m/yr)\")\nplot!(size = (1000,550))","category":"page"},{"location":"generated/bumpy_bed.html#Different-Lengthscales","page":"Flow over a bumpy bed","title":"Different Lengthscales","text":"","category":"section"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"Now let's look at how the velocity along a flowline changes with L.","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"L_values =  [160, 80, 40, 20, 10, 5]*1.0e3;\nnothing #hide","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"We loop over these values and store the info:","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"U_flowline = zeros(80, length(L_values));\ngrid_flowline = zeros(80, length(L_values));\nfor (count,L) in enumerate(L_values) ;\n    gridL = grid(L = L);\n    z_bL = z_b.(gridL.xxh,gridL.yyh; α = 0.5, ω = 2π/L );\n    initial_conditions = InitialConditions(initial_thickness = 1000. .* ones(80, 80));\n    model = Model(grid = gridL,\n                bed_elevation = z_bL,\n                initial_conditions = initial_conditions);\n    update_state!(model);\n    grid_flowline[:, count] .= model.grid.xxh[:, round(Int, gridL.nx/4)];\n    U_flowline[:,count] .= model.fields.gh.u[:, round(Int, gridL.nx/4)];\nend\n\n#And make the plot in a single command\nplot(grid_flowline/1e3,\n    U_flowline,\n    layout = (2,3),\n    framestyle = :box,\n    xlabel = \"x (km)\",\n    ylabel = \"horizontal velocity (m/yr)\",\n    label = :none,\n    title =  [\"160km\" \"80km\" \"40km\" \"20km\" \"10km\" \"5km\"])\nplot!(size = (1000,550))","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"","category":"page"},{"location":"generated/bumpy_bed.html","page":"Flow over a bumpy bed","title":"Flow over a bumpy bed","text":"This page was generated using Literate.jl.","category":"page"},{"location":"data_structure/overview.html#Data-Structure","page":"Overview","title":"Data Structure","text":"","category":"section"},{"location":"data_structure/overview.html","page":"Overview","title":"Overview","text":"WAVI.jl uses a hierachical data structure, which is shown schematically below. This page provides a brief overview of each of these structures; you can find out more information about each of these via the tabs in the sidebar.","category":"page"},{"location":"data_structure/overview.html","page":"Overview","title":"Overview","text":"<center><img src=\"../assets/structure_flowchart.jpeg\" alt=\"\" title=\"\" width=\"500\" height=\"400\" /></center>","category":"page"},{"location":"data_structure/overview.html","page":"Overview","title":"Overview","text":"At the top of the hierarchy are Simulations. Simulations are to be ran! A Simulation object must be passed the sub-structures describing the following (terms in brackets are the names of the corresponding structures in WAVI.jl):","category":"page"},{"location":"data_structure/overview.html","page":"Overview","title":"Overview","text":"Model (Model):  contains all the information about the current state, parameters, initial conditions, and process parametrizations (see below).\nTimestepping Parameters (TimesteppingParams): contains parameters relating to timestepping (e.g. timestep, number of timesteps etc)\nOutput Parameters (OutputParams): optional structure that contains information relativng to the outputting of solutions (what to output, when to output etc).","category":"page"},{"location":"data_structure/overview.html","page":"Overview","title":"Overview","text":"A Model structure contains sub-structures describing the following:","category":"page"},{"location":"data_structure/overview.html","page":"Overview","title":"Overview","text":"Grid (Grid): contains information on the discretization of the model domain (e.g. number of grid cells, grid spacing etc)\nPhysical parameters (Params): contains physical parameters (e.g. density of the ice)\nSolver parameters (SolverParams): contains parameters relating to the velocity solver (e.g. maximum number of iterations)\nInitial conditions (InitialConditions): stores initial conditions relating to the ice sheet.\nFields (Fields): stores information on the current state of the model.","category":"page"},{"location":"data_structure/overview.html","page":"Overview","title":"Overview","text":"A Model also owns a dict named extra_physics, which contains information on parametrizations of physical processes used by the model. See the Parametrizations tab on the left for more information.","category":"page"},{"location":"examples/mismip.html#MISMIP","page":"MISMIP","title":"MISMIP","text":"","category":"section"},{"location":"examples/mismip.html","page":"MISMIP","title":"MISMIP","text":"MISMIP example coming soon!","category":"page"},{"location":"physics/melting.html#Melt-Rates","page":"Melt Rates","title":"Melt Rates","text":"","category":"section"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"WAVI.jl includes a number of community melt rate parametrizations of melt rate:","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"Input file melt rates \nQuadratic temperature parametrization\nPlume emulator parametrization\nPICO parametrization\nPICOP parametrization","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"Further details of these parametrizations can be found on this page. Much of these descriptions is taken from [Favier2019(@cite), which describes a thorough assessment of different melt rate parametrizations. For details of the use of melt rate parametrizations in WAVI.jl, see the melt rate models section. We strongly encourage those who have developed melt rate parametrizations to consider implementing them in WAVI.jl; if you are interested in doing so, see the melt rate models and contributors guide(../contributing.md), or get in touch.","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"WAVI.jl also supports coupling to the ocean model MITgcm. Please get in touch, or see the MITgcm coupling tab if you are interested in running coupled WAVI.jl-MITgcm simulations.","category":"page"},{"location":"physics/melting.html#Input-File-Melt-Rate-Parametrizations","page":"Melt Rates","title":"Input File Melt Rate Parametrizations","text":"","category":"section"},{"location":"physics/melting.html#Quadratic-Temperature-Melt-Rate-Parametrization","page":"Melt Rates","title":"Quadratic Temperature Melt Rate Parametrization","text":"","category":"section"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"The quadratic temperature melt rate parametrization [P R Holland, A Jenkins, D M Holland (2008)] parametrizes the melt rate as a quadratic function of the thermal driving:","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"beginequationlabelEquadratic_parametrization\r\nM = gamma_T left( fracrho_w c_prho_i L right) left(T_0 - T_F right)^2\r\nendequation","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"Here gamma_T is a heat exchange velocity, rho_w is the density of water, rho_i is the density of ice, c_p is the heat capacity of the ocean, L is the latent heat of fusion of ice. In addition, T_F = lambda_1 S_0 + lambda_2 + lambda_3 z_b is the local freezing point, with lambda_1, lambda_2, and lambda_3 the liquidus slope, intercept, and pressure coefficient, respectively, and z_b the height of the ice shelf draft above sea level (i.e. z_b is negative).  T_0 and S_0 are the depth-dependent potential temperatre and practical salinity taken from the far field.","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"The quadratic formulation \\eqref{E:quadratic_parametrization} attempts to account for heat providing both more heat for melting and the feedback between sub-shelf melting and circulation in the cavity (higher temperatures result in a more vigorous circulation, promoting enhanced melt rates).","category":"page"},{"location":"physics/melting.html#Plume-Emulator-Melt-Rate-Parametrization","page":"Melt Rates","title":"Plume Emulator Melt Rate Parametrization","text":"","category":"section"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"The plume emulator melt rate parametrization from Werner MJ Lazeroms, Adrian Jenkins, G Hilmar Gudmundsson, Roderik SW Van De Wal (2018) emulates the 2-D behaviour of the 1-D plume model of Adrian Jenkins (1991). This model describes the evolution of a buoyant plume originating from the grounding line with zero thickness and velocity, and temperature and salinity taken from the ambient ocean. Away from the grounding line, the thickness, velocity, temperature, and salinity of the plume evolve through advection, turbulent exchange across the ocean boundary layer underneath the ice shelf, and entrainment of deep water. ","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"The melt rate in the plume model emulator can be expressed as ","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"beginequationlabelEplume_parametrization\r\nM = alpha M_0 g(theta)(T_0 - T_Fgl)^2 hatM(hatX)\r\nendequation","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"where M_0 is a the melt rate prefactor, alpha is a calibration coefficient, g(theta) is an expression of the mean basal slope at shelf points and hatM is a universal, dimensionless function of hatX, an expression for the dimensionless distance from the grounding line. The mean basal slope theta and dimensionless distance hatX are determined using a path-finding algorithm that is described in detail in Werner MJ Lazeroms, Adrian Jenkins, G Hilmar Gudmundsson, Roderik SW Van De Wal (2018).","category":"page"},{"location":"physics/melting.html#PICO-Melt-Rate-Parametrization","page":"Melt Rates","title":"PICO Melt Rate Parametrization","text":"","category":"section"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"The Potsdam Ice-shelf Cavity mOdel (PICO) melt rate from Ronja Reese, Torsten Albrecht, Matthias Mengel, Xylar Asay-Davis, Ricarda Winkelmann (2018) is based on a one-dimensional ocean box-model which coarsely resolves ice shelf cavities. The box model represents the buoyancy-driven advection of ambient ocean water into the ice-shelf cavity at depth up to the grounding line, then upward along the ice draft in consecutive boxes. The melt rates in the box model are given by ","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"beginequationlabelEpico_parametrization\r\nM = gamma_T left( fracrho_w c_prho_i L right) left(T_0 - T_Fk right)\r\nendequation","category":"page"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"where the subscript k indicates properties evaluated in box k.  Those properties account for the transformation of ocean temperature and salinity in consecutive boxes through heat and salt turbulent exchange across the ocean boundary layer underneath ice shelves.","category":"page"},{"location":"physics/melting.html#PICOP-Melt-Rate-Parametrization","page":"Melt Rates","title":"PICOP Melt Rate Parametrization","text":"","category":"section"},{"location":"physics/melting.html","page":"Melt Rates","title":"Melt Rates","text":"The PICOp melt rate parametrization from [Pelle2019] is a coupling between the PICO and Plume Emulator melt rate parametrizations. This parametrization uses the box model formulation of PICO, but the melt rate within each box is determined using the plume parametrization melt rate \\eqref{E:plumeparametrization}, rather than \\eqref{E:picoparametrization}.","category":"page"},{"location":"data_structure/solver_parameters.html#Solver-Parameters","page":"Solver Parameters","title":"Solver Parameters","text":"","category":"section"},{"location":"data_structure/solver_parameters.html","page":"Solver Parameters","title":"Solver Parameters","text":"A SolverParameters object is a WAVI.jl object that stores parameters related to the numerical solution of the governing equations. The following table summarises these parameters","category":"page"},{"location":"data_structure/solver_parameters.html","page":"Solver Parameters","title":"Solver Parameters","text":"Keyword Argument Description Default Value\nn_iter_viscosity Maximum number of iterations used in determining implicit viscosity 2\nmaxiter_picard Number of Picard iterations in velocity solve 30\ntol_picard Tolerance at which Picard iteration considered to have converged 1e-5\ntol_coarse Relative tolerance at which the adaptive mesh is coarsened ∘C/m\nmaxiter_coarse Maximum number of coarsening iterations 1000\nlevels Number of wavelet levels 3\nwavelet_threshold  10.0\nnsmooth  5\nsmoother_omega  1.0\nstencil_margin  3","category":"page"},{"location":"installation_instructions.html#Installation-instructions","page":"Installation instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions.html","page":"Installation instructions","title":"Installation instructions","text":"You can install the latest version of WAVI using the built-in package manager (accessed by pressing ] in the Julia command prompt) to add the package and instantiate/build all dependencies","category":"page"},{"location":"installation_instructions.html","page":"Installation instructions","title":"Installation instructions","text":"julia>]\r\n(v1.6) pkg> add https://github.com/RJArthern/WAVI.jl\r\n(v1.6) pkg> instantiate","category":"page"},{"location":"installation_instructions.html","page":"Installation instructions","title":"Installation instructions","text":"Note that WAVI is only tested on Julia versions 1.5 and newer; stability cannot be guaranteed on newer versions!","category":"page"},{"location":"installation_instructions.html","page":"Installation instructions","title":"Installation instructions","text":"At this time, updating should be done with care, as WAVI is under rapid development. While we take care to avoid breaking changes, they may happen during this time. If anything does break, please open an issue and let us know!","category":"page"},{"location":"examples/MISI.html#Marine-Ice-Sheet-Instability-(MISI)","page":"Marine Ice Sheet Instability (MISI)","title":"Marine Ice Sheet Instability (MISI)","text":"","category":"section"},{"location":"examples/MISI.html","page":"Marine Ice Sheet Instability (MISI)","title":"Marine Ice Sheet Instability (MISI)","text":"MISI example coming soon!","category":"page"},{"location":"physics/overview.html#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"physics/overview.html","page":"Overview","title":"Overview","text":"WAVI.jl is a software package for the numerical solution of the hybrid equations describing the evolution of ice sheet thickness h and velocity mathbfu = (uv). Hybrid models assume that ice sheet stresses are depth independent, but vertical velocity gradients are included in the non-linear viscosity and treatment of basal stress. This means that unlike models that make the shallow-ice or shallow-shelf approximations, they are appropriate to describe both regions of fast and slow ice flow, while being computationally two-dimensional and thus far less expensive than full Stokes models. An excellent introduction to the heirarchy of different types of ice sheet model, and the physical processes they capture, can be found on the Antarctic Glaciers website.","category":"page"},{"location":"physics/calving.html#Calving","page":"Calving","title":"Calving","text":"","category":"section"},{"location":"physics/calving.html","page":"Calving","title":"Calving","text":"What is calving?\nWhy is it important for dynamics?\nHow does WAVI deal with calving fronts?","category":"page"},{"location":"examples/WAIS.html#West-Antarctic-Ice-Sheet-(WAIS)","page":"West Antarctic Ice Sheet (WAIS)","title":"West Antarctic Ice Sheet (WAIS)","text":"","category":"section"},{"location":"examples/WAIS.html","page":"West Antarctic Ice Sheet (WAIS)","title":"West Antarctic Ice Sheet (WAIS)","text":"WAIS example coming soon!","category":"page"},{"location":"physics/damage.html#Damage","page":"Damage","title":"Damage","text":"","category":"section"},{"location":"physics/damage.html","page":"Damage","title":"Damage","text":"Why is ice damage important?\nWhere does it enter into the equations in WAVI.jl?\nModels for ice damage coming soon.","category":"page"},{"location":"numerical_procedure/numerical_procedure.html#Numerical-Grid","page":"Numerical Implementation","title":"Numerical Grid","text":"","category":"section"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"WAVI.jl solves the governing equations on a rectangular grid, with n_x grid cells in the x direction and n_y grid cells in the y direction. Ice thickness values h are defined at the cell centers (see figure) of grid cells, while velocity components baru and barv are defined along grid cell edges, and shear strain rates c = (partial u partial y + partial v  partial x)2 are stored at grid corners.","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"<center><img src=\"../assets/grid-schematic.jpg\" alt=\"\" title=\"\" width=\"400\" height=\"400\" />\r\n<figcaption>Figure 1: Locations within grid cells that ice thickness $h$, velocity components $u$ and $v$, and shear strain rates $c = (\\partial u /\\partial y + \\partial v / \\partial x)/2$ are stored. </figcaption></center>","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"The set of all such points at which the ice thickness is stored defines the h-grid. The u-grid, v-grid, and c-grid are defined analagously. Various different quantities are also stored on each of these grids, and used as part of the solution (see Fields for more information).","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"Three dimensional fields used in the governing equations (e.g. viscosity) are stored h-grid points, extrapolated into the z direction. This grid is referred to as the sigma-grid.","category":"page"},{"location":"numerical_procedure/numerical_procedure.html#Problem-Reduction","page":"Numerical Implementation","title":"Problem Reduction","text":"","category":"section"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"This section contains brief details of the procedure by which the momentum balance equations governing equations(2)–(4) are reduced to a non-linear equation for the depth average velocity barmathbfu. For full details, refer to Robert J Arthern, Richard CA Hindmarsh, C Rosie Williams (2015).","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"To make progress in solving the governing equations, horizontal gradients in vertical velocity are neglected and vertical shear stresses are assumed to vary linearly with depth. Then, if the ice thickness h, surface elevation h, ice stiffness, basal stresses and horizontal stress components are known, the depth integrated viscosity ","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"beginequation\r\n    bareta = frac1hint_s - h^h etamathrmdz\r\nendequation","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"can be computed numerically. Here eta is the ice viscosity (equation (4) in thegoverning equations).","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"After depth integrating the approximation to the horizonal stress components, and using the Robin boundary condition (equation (7)), the basal velocity components – and thus basal stress terms – can be expressed in terms of the depth averaged velocity components. The basal stress components can then be eliminated from  governing equations(2)–(3), which can therefore be expressed as a non-linear problem for barmathbfu, the depth averaged velocity:","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"beginequation\r\nmathcalL(barmathbfu) barmathbfu = mathbff\r\nendequation","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"where","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"beginequationlabelEoperator_problem\r\nmathcalL = beginpmatrix \r\npartial_x 4 bareta h partial_x + partial_y  bareta h partial_y - beta_texteff  partial_x 2 bareta h partial_y + partial_y  bareta h partial_x \r\npartial_x bareta h partial_y + partial_y 2  bareta h partial_x  partial_x  bareta h partial_x + partial_y 4 bareta h partial_y - beta_texteff \r\nendpmatrix\r\nendequation","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"with beta_texteff an effective drag coefficient (see equation (12) in Robert J Arthern, Richard CA Hindmarsh, C Rosie Williams (2015)).","category":"page"},{"location":"numerical_procedure/numerical_procedure.html#Velocity-Solve","page":"Numerical Implementation","title":"Velocity Solve","text":"","category":"section"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"This section described very briefly the steps involved in the procedure by which the non-linear elliptic problem for the velocity (equation \\eqref{E:operator_problem}) is solved in WAVI.jl. Again, for full details, refer to Robert J Arthern, Richard CA Hindmarsh, C Rosie Williams (2015).","category":"page"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"The problem \\eqref{E:operator_problem} is discretized with a finite difference approximation. Details of the discretization are included in the appendix of Robert J Arthern, Richard CA Hindmarsh, C Rosie Williams (2015). \nThe resulting problem is expressed as a symmetric saddle point problem. \nThe saddle point problem is expressed as two distinct problems. The first is solver iteratively using a BiCGSTAB method\nThe second problem is solved using an iterative method, leveraging an [LU-factorization] of the mass matrix in the problem.","category":"page"},{"location":"numerical_procedure/numerical_procedure.html#Timestepping","page":"Numerical Implementation","title":"Timestepping","text":"","category":"section"},{"location":"numerical_procedure/numerical_procedure.html","page":"Numerical Implementation","title":"Numerical Implementation","text":"If the system is to be solved forwards in time, the velocity must be solved simultanously with the surface elevation (i.e. equations (2)–(4) and (8)) must be solved simultanously. The procedure is largely as described above for the velocity components, but the problem is preconditioned using an iterative approach inspired by Oleg V Vasilyev, Nicholas K-R Kevlahan (2005) to improve computational speed. Once the velocities have been solved for, the surface elecation is updated using a simple Euler scheme.","category":"page"},{"location":"examples/Greenland.html#Greenland","page":"Greenland","title":"Greenland","text":"","category":"section"},{"location":"examples/Greenland.html","page":"Greenland","title":"Greenland","text":"Greenland example coming soon!","category":"page"},{"location":"examples/mismip_3d.html#MISMIP-3D","page":"MISMIP 3D","title":"MISMIP 3D","text":"","category":"section"},{"location":"examples/mismip_3d.html","page":"MISMIP 3D","title":"MISMIP 3D","text":"MISMIP example coming soon!","category":"page"},{"location":"data_structure/timestepping_params.html#Timestepping-Parameters","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"","category":"section"},{"location":"data_structure/timestepping_params.html#Overview","page":"Timestepping Parameters","title":"Overview","text":"","category":"section"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"A TimesteppingParams structure is used to pass information relating to timestepping to the simulation. The following parameters as specified by passing appropriate keyword arguments the TimesteppingParams constructor:","category":"page"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"niter0: the iteration number at which the simulation. Set niter0 to 0 to initialize a 'clean' simulation, or niter0 to a positive integer to (attempt to) pickup from the a corresponding checkpoint (see Checkpoints and Pickups below)\ndt: the simulation timestep\nend_time: the clock time at which the simulation should terminate\nn_iter_total: the total number of timesteps to be performed. NB: you must specify at least one of end_time and n_iter_total (the simulation must know when it is going to finish!); specifying both is possible, but they must be compatible (i.e the end_time must equal n_iter_total * dt).\nchkpt_freq and pchkpt_freq: the model time interval between outputting temporary and permanent checkpoints, respectively (see Checkpoints and Pickups)\nstep_thickness: a flag which, when turned off (stepthickness = false) turns of thickness updates when timestepping. This is an experimental feature, necessary for coupling WAVI to the MITgcm (see the MITgcm coupling for more info)","category":"page"},{"location":"data_structure/timestepping_params.html#Constructor","page":"Timestepping Parameters","title":"Constructor","text":"","category":"section"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"An instance of a TimesteppingParams is constucted using the TimesteppingParams(;<kwargs>) constructor:","category":"page"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"TimesteppingParams()","category":"page"},{"location":"data_structure/timestepping_params.html#WAVI.TimesteppingParams-Tuple{}","page":"Timestepping Parameters","title":"WAVI.TimesteppingParams","text":"TimesteppingParams(;                     niter0 = 0,                     dt = 1.0,                     endtime = 1.0,                     t0 = nothing,                     chkptfreq = Inf,                     pchkptfreq = Inf,                     chkptpath = './',                     step_thickness = true)\n\nConstruct a WAVI.jl TimesteppingParams object. TimesteppingParams stores information relating to timestepping.\n\nKeyword arguments\n\n'niter0': Iteration number of the first timestep. niter0 = 0 corresponds to a new simulation, while niter0 > 0 (positive integer) corresponds to a pickup.\n'dt': Model timestep\n'end_time': Simulation termination time\n't0': Starting time of the simulation\n'chkpt_freq': Frequency of outputting temporary checkpoints\n'pchkpt_freq': Frequecy with which permanent checkpoints are pass\n'chkpt_path' : Path to location checkpoint output\n'step_thickness': Toggle whether to update the ice thickness (true) or not (false) at each timestep\n\n\n\n\n\n","category":"method"},{"location":"data_structure/timestepping_params.html#Checkpoints-and-Pickups","page":"Timestepping Parameters","title":"Checkpoints and Pickups","text":"","category":"section"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"Large simulations are computationally expensive, and may take a long time to run. To permit simulations to run for longer than maximum runtime limits which are imposed on many machines, WAVI.jl is equipped with a checkpoint-pickup system that allows the state to be outputted frequently, and the simulation to be picked again from that point. ","category":"page"},{"location":"data_structure/timestepping_params.html#Checkpoints","page":"Timestepping Parameters","title":"Checkpoints","text":"","category":"section"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"Checkpoints contain a snapshot of all of the information on the current state of the simulation. As a result, they may be large and thus outputting checkpoints very frequently is discouraged, except for when debugging simulations which are ran for only a few timesteps (see Simulation Tips)","category":"page"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"Both temporary and permanent checkpoints are output in jld2 format. The path of both of these is specified by setting the chkpt_path argument in the TimesteppingParams constructor.","category":"page"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"Temporary checkpoints are outputted every chkpt_freq years (model time). These checkpoints are rolling: first checkpoint 'A' (named chkptA.jld) is written at time chkpt_freq, then checkpoint 'B' (named chkptB.jld) is output at a time 2 * chkpt_freq. Checkpoint 'A' is overwritten at time 3 * chkpt_freq, and so on.","category":"page"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"Similarly, permanent checkpoints are outputted every pchkpt_freq model years.  These are output sequentially (i.e. not overwritten) as pchkpt_xxxxxxxxx.jld2 where xxxxxxxxxx is the iteration number, prepended by zeros to be ten digits long (e.g. the filename of a checkpoint outputted at timestep number one thousand is chkpt_0000001000.jld).","category":"page"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"Note that the number of timesteps, rather than the model time, is used to determine when to output the solution: permanent checkpoints are output every floor(pchkpt_freq / dt) timesteps (and similarly for chkpt_freq), so the actual output frequency may not exaclty match that specified by the parameter. ","category":"page"},{"location":"data_structure/timestepping_params.html#Pickups","page":"Timestepping Parameters","title":"Pickups","text":"","category":"section"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"Continuining from the state stored in a checkpoint is initiatied by setting the niter0 parameter to correspond to the number of the timestep to be picked up from. For example, to continue the simulation from a checkpoint outputted at timestep number one thousand, set niter0 = 1000 in the TimesteppingParams constructor.  ","category":"page"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"WAVI.jl only currently supports pickups from permanent checkpoints. The permanent checkpoint from which a pickup is initiated must be in the local directory.","category":"page"},{"location":"data_structure/timestepping_params.html","page":"Timestepping Parameters","title":"Timestepping Parameters","text":"note: Note\nAfter a pickup, WAVI.jl uses the model that was specified in the original simulation that produced the checkpoint. However, to retain the simulation structure, a model must still be passed to simulation Similarly, after picking up, output_params will be as specified in the original simulation that produced the checkpoint. To force a simulation to update to the model and/or output parameters to those just passed, use the pickup_model_update_flag and/or pickup_output_update_flag flags in the simulation constructor (see Simulations). TimesteppingParams are always updated after a pickup.  ","category":"page"},{"location":"examples/Antarctica.html#Antarctica","page":"Antarctica","title":"Antarctica","text":"","category":"section"},{"location":"examples/Antarctica.html","page":"Antarctica","title":"Antarctica","text":"Antractica example coming soon!","category":"page"},{"location":"physics/governing_equations.html#Governing-Equations","page":"Governing Equations","title":"Governing Equations","text":"","category":"section"},{"location":"physics/governing_equations.html#Preliminaries","page":"Governing Equations","title":"Preliminaries","text":"","category":"section"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"WAVI.jl uses a Cartesian co-ordinate system mathbfx = (xyz), with z positive upwards; the corresponding velocity components are mathbfu = (uvw). We use bar notation to denote depth averaged quantities, for example:","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"    beginequation\r\n        barf =frac1h int_z = b(xy)^z = s(xyt)fmathrmdz\r\n    endequation","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"is the depth average of the quantity f. Here, t is the denotes time, b(xy) is the (known) bed elevation (measured positive upwards), and s(xyt) is the surface elevation. ","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"We assume that the ice is in hydrostratic equilibrium, so that regions are with h  -(rho_irho_w) b are floating, and regions with h geq -(rho_irho_w) b are grounded, where rho_i and rho_w the ice and ocean density, respectively.  Where the ice is grounded, we have s = h + b, while where the ice is floating, the hydrostratic assumption enforces s = (1 - rho_irho_w)h.","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"WAVI.jl solves equations describing conservation of momentum and conservation of mass for mathbfbaru(xyt) = (baru(xyt) barv(xyt)), the depth averaged velocity components in the (xy) directions, respectively, and the ice thickness h(xyt)","category":"page"},{"location":"physics/governing_equations.html#Conservation-of-Momentum","page":"Governing Equations","title":"Conservation of Momentum","text":"","category":"section"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"Conservation of momentum requires that the baru and barv satisfy (D N Goldberg (2011)):","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"beginalign\r\n    fracpartialpartial xleft(4 baretah fracpartial barupartial x + 2 baretah fracpartial barvpartial y)right) +    fracpartialpartial yleft(baretah fracpartial barvpartial x +  baretah fracpartial barupartial yright) - tau_bx = rho_i g h fracpartial spartial x labelEx-momentum\r\n    fracpartialpartial yleft(4 baretah fracpartial barvpartial y + 2 baretah fracpartial barupartial x)right) +    fracpartialpartial xleft(baretah fracpartial barupartial y +  baretah fracpartial barvpartial xright) - tau_by = rho_i g h fracpartial spartial ylabelEy-momentum\r\nendalign","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"where rho_i is the ice density, g is the gravitational acceleration, mathbftau_b = (tau_bx tau_by) is the basal drag in the (xy) directions, and eta is the ice viscosity, defined implicity in terms of the velocity components (the strain components are themselves functions of eta, see below):","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"beginequationlabelEviscosity\r\n    eta = fracB2 leftleft(fracpartial barupartial xright)^2  + left(fracpartial barvpartial yright)^2 + fracpartial barupartial xfracpartial barvpartial y + frac14left( fracpartial barupartial y + fracpartial barupartial xright)^2 + frac14left(fracpartial barupartial zright)^2 + left(fracpartial barvpartial zright)^2 + epsilon^2right^frac1-n2n\r\nendequation","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"Here n is the exponent in a nonlinear Glen flow law, epsilon is a regularization parameter that prevents the viscosity becoming unbounded at small strain rates (for small strain rates, eta is constant, corresponding to a linear rheology), and B(xyz) is a temperature-dependent coefficient that determines the stiffness of the ice. ","category":"page"},{"location":"physics/governing_equations.html#Boundary-Conditions","page":"Governing Equations","title":"Boundary Conditions","text":"","category":"section"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"The momentum equations are solved alongside boundary conditions at the lateral boundary of the ice sheet,","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"    beginalign\r\n        -frac12rho_w  h_w^2 hatn_x = 2baretahleft(2 fracpartial barupartial x + fracpartial barvpartial yright)hatn_y - frac12rho_i g h^2 hatn_x + baretah left(fracpartial barupartial y + fracpartial barvpartial xright)hatn_ylabelEbc1\r\n        -frac12rho_w  h_w^2 hatn_y = 2baretahleft(2 fracpartial barvpartial y + fracpartial barupartial xright)hatn_y - frac12rho_i g h^2 hatn_y + baretah left(fracpartial barupartial y + fracpartial barvpartial xright)hatn_x labelEbc2\r\n     endalign","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"which impose continuity of depth-integrated momentum there. In \\eqref{E:bc1}–\\eqref{E:bc2}, h_w = max(h - s + zeta 0) is the thickness of ice below the water level, where zeta is the sea level with respect to z = 0, and hatmathbfn = (hatn_x hatn_y) is the normal to the lateral boundary. ","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"In addition, a Robin boundary condition at the bed linearly relates the basal stress tau_b = (tau_bxtau_by) to the basal velocity mathbfu_b via a multiplicative drag coefficient beta:","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"    beginalign\r\n        tau_b = beta  mathbfu_b\r\n    endalign","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"(A no-stress condition at the surface is also implicit in the derivation of~\\eqref{E:x-momentum}–\\eqref{E:x-momentum}.)","category":"page"},{"location":"physics/governing_equations.html#Conservation-of-Mass","page":"Governing Equations","title":"Conservation of Mass","text":"","category":"section"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"For a given depth-averaged velocity mathbfbaru, accumulation rate a(xyt) (positive for ice gain), and basal melt rate m(xyt) (positive for ice loss), conservation of ice mass requires that the ice thickness h satisfies","category":"page"},{"location":"physics/governing_equations.html","page":"Governing Equations","title":"Governing Equations","text":"    beginequationlabelEmass_cons\r\n        fracpartial hpartial t = a - m - nabla left(h mathbfuright)\r\n    endequation","category":"page"},{"location":"data_structure/fields.html#Fields","page":"Fields","title":"Fields","text":"","category":"section"},{"location":"data_structure/fields.html","page":"Fields","title":"Fields","text":"WAVI.jl stores information relating to the solutions on fields, which are stored in the model. Fields are organised based according to the different grids (HGrid, CGrid etc – see Grids) that quantities are stored. Note that all quantities here are set internally (i.e. they cannot be modified by the user). This page contains a full directory of the quantities defined on each of the Grids: HGrid, UGrid, VGrid, CGrid, SigmaGrid.","category":"page"},{"location":"data_structure/fields.html#HGrid","page":"Fields","title":"HGrid","text":"","category":"section"},{"location":"data_structure/fields.html","page":"Fields","title":"Fields","text":"The following quantities are stored in the HGrid structure within Fields (accessible via model.fields.gh.<field_name>):","category":"page"},{"location":"data_structure/fields.html","page":"Fields","title":"Fields","text":"h: Ice thickness\nb: Bed elevation\ns: Ice surface elevation (s = b + h)\ndhdt: Time rate of change of surface elevation\naccumulation: Ice accumulation rate (postive for mass added to the surface, negative for mass removed)\nbasal_melt: Melt rate applied to the base of the ice sheet (positive for mass removed from the base, negative for mass added).\ngrounded_fraction: Grid cell grounded fraction (zero in the shelf, one in the shelf and interpolated across the grounding line, see Seroussi et al. (2014))\nu: Depth average ice velocity in the x direction.\nv: Depth average ice velocity in the y direction.\nav_speed: Depth averaged ice speed \nus: Surface ice velocity in the x direction.\nvs: Surface ice velocity in the y direction.\nub: Base ice velocity in the x direction.\nvb: Base ice velocity in the y direction.\nbed_speed: Ice speed at the base\nweertman_c: Weertman C drag cofficient\nhaf: The height above floatation\ndsdh: Rate of change of surface elevation with respect to thickness change\nshelf_strain_rate: Strain rate computed using only longitudinal strain components\nβ: Raw multiplicative drag coefficient\nβeff: Effective multiplicative drag coefficient\nτbed: Ice stress at the bed.\nηav: Depth averaged viscosity\nquad_f1: F_1 computed from numerical quadrature\nquad_f2: F_2 computed from numerical quadrature\nmask: boolean matrix that defines the solution space","category":"page"},{"location":"data_structure/fields.html","page":"Fields","title":"Fields","text":"For convenience, various utility matrices and rheological operators are also stored on the HGrid:","category":"page"},{"location":"data_structure/fields.html","page":"Fields","title":"Fields","text":"crop: diagonal matrix with mask entries on the diagonal \nsamp: boolean matrix that takes full domain to the model domain\nspread: sparse form of the sampling matrix\ndneghηav: -h times bareta\ndimplicit: -rho_i times g times mathrmdt times mathrmdhmathrmds","category":"page"},{"location":"data_structure/fields.html#UGrid","page":"Fields","title":"UGrid","text":"","category":"section"},{"location":"data_structure/fields.html#VGrid","page":"Fields","title":"VGrid","text":"","category":"section"},{"location":"data_structure/fields.html#CGrid","page":"Fields","title":"CGrid","text":"","category":"section"},{"location":"data_structure/fields.html#SigmaGrid","page":"Fields","title":"SigmaGrid","text":"","category":"section"},{"location":"data_structure/model.html#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"data_structure/model.html","page":"Models","title":"Models","text":"A Model is a WAVI.jl strcutures that contain all the information about the current state, parameters, initial conditions, and process parametrizations. An instance of a Model contains the following fields:","category":"page"},{"location":"data_structure/model.html","page":"Models","title":"Models","text":"grid: an instance of a WAVI.jl Grid object, that stores information about the numerical grid.\nparams: an instance of a WAVI.jl Params object that stores phyiscal parameters that enter the model.\nsolver_params: an instance of a WAVI.jl SolverParams object that stores parameters relating to the numerical solution of the governing equations (see numerical implementation).\ninitial_conditions: an instance of a WAVI.jl InitialConditions object that stores initial data on the ice thickness, ice viscosity, ice temperature, and ice damage.\nfields: an instance of a WAVI.jl Fields structure that stores information relating to the current state of the model on the various grids used in the solution (see numerical implementation for more information on these grids)\nextra_physics: a dictionary that stores process parametrizations used in the ice sheet model (see process parametrizations for more information).","category":"page"},{"location":"data_structure/model.html#Model-Construction","page":"Models","title":"Model Construction","text":"","category":"section"},{"location":"data_structure/model.html","page":"Models","title":"Models","text":"A Model is constructed using the Model(;<kwargs>) constructor (a function that constructs an instance of a Model). Here <kwargs> is shorthand for keyword arguments, allow the Model to be configured, some are optional and others are not (see below):","category":"page"},{"location":"data_structure/model.html","page":"Models","title":"Models","text":"Model()","category":"page"},{"location":"data_structure/model.html#WAVI.Model-Tuple{}","page":"Models","title":"WAVI.Model","text":"Model constructor\n\n\n\n\n\n","category":"method"},{"location":"data_structure/output_writing.html#Output-Writing","page":"Output Writing","title":"Output Writing","text":"","category":"section"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"Parameters relating to writing solution data are stored in an OutputParams structure. Data is output as individual files at a user-specified interval, and may be zipped to a single file once the simulation has completed.","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"The key parameters, which are passed via keyword arguments in the OutputParams constructor, are as follows:","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"outputs: a named tuple that points to data fields to be output. Variable names used in the output are those specified in the named tuple. For example, to set the outputs to be the ice sheet thickness, named h, and the ice sheet surface elevation, named s, we would first instantiate a Model (here named model) and set outputs = (h = model.fields.gh.h, s = model.fields.gh.s).","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"note: Note\nIf only outputting a single field, you must include a comma so that Julia interprets it as a named tuple, e.g. outputs = (h = model.fields.gh.h,).","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"note: Note\nVariables named x, y, and TIME are reserved for the spatial and temporal dimensions and are therefore not permitted as variable names.","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"output_freq: the model time frequency with which the simulation is output. Note that WAVI works with the number of timesteps per output, calculated as floor(output_freq/dt) where dt is the simulation timestep. If output_freq is not an integer multiple of dt, this will introduce differences in the actual output frequency, and that specified by the user.","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"output_format specifies the file format that the solution are to be saved in. Currently only .jld2 and .mat file formats are supported. ","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"prefix specifies the prefix of solution files. Output files are saved as <prefix>_xxxxxxxxxx.jld where xxxxxxxxxx is the timestep number at which this solution was outputted, prepended with zeros to be ten digits in length. ","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"output_path specifies the path (relative or absolute) into which the solution is outputted. Note that if the specified path does not exist, outputs will be written to the local directory. ","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"zip_format specifies the format that solution files are zipped into. Currently WAVI.jl only supports zipping to an nc format. ","category":"page"},{"location":"data_structure/output_writing.html","page":"Output Writing","title":"Output Writing","text":"dump_vel is a shortcut to dump the velocity at the end of a simulation. This is an experimental feature, necessary for coupling WAVI to the MITgcm (see the MITgcm coupling tab).","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"EditURL = \"<unknown>/examples/melt_rate_parametrizations.jl\"","category":"page"},{"location":"generated/melt_rate_parametrizations.html#Melt-rates","page":"Melt rate parametrizations","title":"Melt rates","text":"","category":"section"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"This example demonstrates the wealth of melt rate parametrizations that are included in WAVI.jl. We produce a picture of the melt rate for the MISMIP+ steady state geometry for each of the melt rate specifications included in WAVI.jl. These are:","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Quadratic melt rates\nA plume melt emulator\nPICO melt rate model\nBinary file melt rate","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"You can find more info on each of these models in the Physics tab.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"We also demonstrate how to add a simple melt rate model to WAVI.jl.","category":"page"},{"location":"generated/melt_rate_parametrizations.html#Install-dependencies","page":"Melt rate parametrizations","title":"Install dependencies","text":"","category":"section"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"using Pkg\npkg\"add WAVI, Plots\"","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"using WAVI, Plots, Downloads","category":"page"},{"location":"generated/melt_rate_parametrizations.html#Set-up-grid","page":"Melt rate parametrizations","title":"Set up grid","text":"","category":"section"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"First we'll make the grid, which has 2km resolution, with 320 grid points in the x-direction and 40 grid points in the y-direction.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"nx = 320;\nny = 40;\ngrid = Grid(nx=nx,\n            ny=ny,\n            dx=2000.,\n            dy=2000.);\nnothing #hide","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"We'll cheat and use the MISMIP+ bed, which is hard coded into WAVI.jl (see the overdeepened bed example to see how to do this properly)","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"bed = WAVI.mismip_plus_bed # function definition","category":"page"},{"location":"generated/melt_rate_parametrizations.html#Getting-the-ice-thickness","page":"Melt rate parametrizations","title":"Getting the ice thickness","text":"","category":"section"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"To save time, we're going to pull the steady state ice thickness from online, where it is stored as a binary file. (this ice thickness is the result of the overdeepened bed example with 2km resolution).","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"fname = Downloads.download(\"https://github.com/alextbradley/MISMIP_data/raw/main/WAVI_ice0_2km_thick.bin\");\nh = Array{Float64,2}(undef, nx, ny);\nread!(fname, h)\nh = ntoh.(h)","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"The final line converts the endianness from big-endian to little-endian. Lets make an InitialConditions object to store this ice thickness.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"initial_conditions = InitialConditions(initial_thickness = h)","category":"page"},{"location":"generated/melt_rate_parametrizations.html#Melt-Rate-Models","page":"Melt rate parametrizations","title":"Melt Rate Models","text":"","category":"section"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"We'll loop over the melt rate models, producing a map of the melt rate in the MISMIP+ geometry each time. First let's make the melt rate models in turn, starting with quadratic. The parameter gamma_T is a normalization cofficient, chosen so that the mean melt rate on the shelf is approx 10m/a.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"melt_quad = QuadraticMeltRate(γT = 0.745*1e-3)","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Next up: PICO. For this parametrization, we have to pass a mask defining where the ice front is:","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"ice_front_mask = zeros(nx,ny);\nice_front_mask[end,:] .= 1;\nmelt_PICO = PICO(ice_front_mask = ice_front_mask,\n                    T0 = 1.2,\n                    S0 = 34.6,\n                    γT = 0.87e-5,\n                    nbox = 5);\nnothing #hide","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Again, gamma_T is a normalization coefficient. See the PICO page for a descritpion of the other parameters listed here.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Now: plume model emulator:","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"melt_PME = PlumeEmulator(α=1.49)","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"In this case, the normalization coefficent is named alpha, and has a slightly different meaning.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Finally, a binary file, in which the melt rate is read in from a file. First, we'll create such a file, which will set the melt rate to be unifrom on the shelf.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"isfloat = (h .< -918.0/1028.0 .* bed.(grid.xxh, grid.yyh)) #indices of floating elements\nm = zeros(nx,ny)\nm[isfloat] .= 10.0 #set everywhere floating to 10m/a\nfolder = joinpath(@__DIR__, \"melt_rate_parametrizations\");\nisdir(folder) && rm(folder, force = true, recursive = true);\nmkdir(folder) ;\nout = open(joinpath(folder,\"melt.bin\"), \"w\")\nwrite(out, m)\nclose(out)","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Now we can point our binary file melt rate here","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"binfile_melt = BinfileMeltRate(input_filename = joinpath(folder,\"melt.bin\"))","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Let's put these into a dictionary:","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"melt_rates = Dict(\"Quadratic\" => melt_quad, \"PME\" => melt_PME, \"PICO\" => melt_PICO, \"Binary file\" => binfile_melt)","category":"page"},{"location":"generated/melt_rate_parametrizations.html#Visualizing","page":"Melt rate parametrizations","title":"Visualizing","text":"","category":"section"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"We'll loop over the melt rate specifiers. Each time, we make a model with the appropriate melt rate specifier using the 'melt_rate' keyword.  We update it to bring the melt in line and plot the results. We set the number of Picard iterations to 1 (we don't care about the velocity being accurate!)","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"for (key, melt) in melt_rates\n    model = Model(grid = grid,\n            bed_elevation = bed,\n            initial_conditions = initial_conditions,\n            solver_params = SolverParams(maxiter_picard=1),\n            melt_rate = melt);\n\n    update_state!(model);\n    m = deepcopy(model.fields.gh.basal_melt)\n    m[model.fields.gh.grounded_fraction .== 1.] .= NaN\n    msat = deepcopy(m)\n    msat[msat .> 50] .= 50\n\n    plt = Plots.heatmap(model.grid.xxh[:,1]/1e3, model.grid.yyh[1,:]/1e3, msat',\n                        xlabel = \"x (km)\",\n                        ylabel = \"y (km)\",\n                        colorbar_title = \"melt rate (m/yr)\",\n                        title = key,\n                        framestyle = \"box\")\n    xlims!((420, 640))\n    plot!(size = (500,300))\n    display(plt)\nend","category":"page"},{"location":"generated/melt_rate_parametrizations.html#Defining-A-New-Melt-Rate-Model","page":"Melt rate parametrizations","title":"Defining A New Melt Rate Model","text":"","category":"section"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"In this section, we show how to specify a new melt rate model, which takes the melt rate according to the MISMIP+ experiment: melt rate on floating cells in 02 tanh((z_d - z_b)75) max(-100 - z_d0) where z_d is the ice shelf draft and z_d - z_b is the cavity thickness. There are three steps. First, we define a structure which stores parameters:","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"struct MISMIPMeltRateOne{T <: Real} <: AbstractMeltRate\n    α  :: T\n    ρi :: T\n    ρw :: T\nend","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"In this case, a normalization coefficient alpha, and the denisities of ice and ocean, rho_i and rho_w, respectively.","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Now we define a constructor, a function that defines how to create one of these structures","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"MISMIPMeltRateOne(; α = 1.0, ρi = 918.0, ρw = 1028.0) = MISMIPMeltRateOne(α,ρi, ρw)","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"The final step is to define a function \"updatemeltrate!(melt_rate::TYPE, fields, grid)\" which tells WAVI how to update the melt rate in this example. here, TYPE is the name of the structure we just made. Note that the arguments of this function must be as mentioned here, so that the multiple dispatch capability can be leveraged!","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"function update_melt_rate!(melt_rate::WAVI.MISMIPMeltRateOne, fields, grid)\n    @unpack basal_melt, h, b  = fields.gh\n    draft = -(melt_rate.ρi / melt_rate.ρw) .* h\n    cavity_thickness = draft .- b\n    cavity_thickness = max.(cavity_thickness, 0)\n    m =  melt_rate.α .* 0.2*tanh.(cavity_thickness./75).*max.((-100 .- draft), 0)\n    basal_melt[:] .= m[:]\nend","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Now we can plot the melt rate with this model:","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"model = Model(grid = grid,\n            bed_elevation = bed,\n            initial_conditions = initial_conditions,\n            solver_params = SolverParams(maxiter_picard=1),\n            melt_rate = MISMIPMeltRateOne());\n\nupdate_state!(model);\nm = deepcopy(model.fields.gh.basal_melt)\nm[model.fields.gh.grounded_fraction .== 1.] .= NaN\nmsat = deepcopy(m)\nmsat[msat .> 50] .= 50\n\nplt = Plots.heatmap(model.grid.xxh[:,1]/1e3, model.grid.yyh[1,:]/1e3, msat',\n            xlabel = \"x (km)\",\n            ylabel = \"y (km)\",\n            colorbar_title = \"melt rate (m/yr)\",\n            title = key,\n            framestyle = \"box\")\nxlims!((420, 640))\nplot!(size = (500,300))\ndisplay(plt)","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"Finally, let's clean up the files we just made","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"rm(folder, force = true, recursive = true);\nnothing #hide","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"","category":"page"},{"location":"generated/melt_rate_parametrizations.html","page":"Melt rate parametrizations","title":"Melt rate parametrizations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"EditURL = \"<unknown>/examples/overdeepened_bed.jl\"","category":"page"},{"location":"generated/overdeepened_bed.html#MISMIP-example","page":"Two-dimensional flow with overdeepened bed","title":"MISMIP+ example","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"This example demonstrates the Marine Ice Sheet Model Intercomparison (MISMIP) + ice0 experiment (doi: 10.5194/tc-14-2283-2020). This intercomparison exercise considers a plan-view ice sheet, in which the grounding line can stabilize on a section of bed which has a locally positive slope in the flow direction. Such configurations are theoretically impossible in one horizontal dimension (see doi: 10.1029/2006JF000664), demonstrating the importance of variations in the second dimension for buttressing ice sheets. This example demonstrates how to apply boundary conditions in WAVI.jl, and control the number of iterations in the velocity solve, and zip the output into a friendly format.","category":"page"},{"location":"generated/overdeepened_bed.html#Install-dependencies","page":"Two-dimensional flow with overdeepened bed","title":"Install dependencies","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"using Pkg\npkg\"add WAVI, Plots\"","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"using WAVI, Plots, NetCDF","category":"page"},{"location":"generated/overdeepened_bed.html#Basal-Topography","page":"Two-dimensional flow with overdeepened bed","title":"Basal Topography","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"The MISMIP+ domain is 640km in the x-direction and 80km in the y-direction, centred around y = 0. The basal topography is given by z_b = max B_x(x) + B_y(y) -720 where B_x(x) is a sixth order, even polynomial and B_y(y) introduces two bumps in the domain:","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"function mismip_plus_bed(x,y)\n    xbar = 300000.0\n    b0 = -150.0; b2 = -728.8; b4 = 343.91; b6 = -50.75;\n    wc = 24000.0; fc = 4000.0; dc = 500.0;\n    bx(x)=b0+b2*(x/xbar)^2+b4*(x/xbar)^4+b6*(x/xbar)^6;\n    by(y)= dc*( (1+exp(-2(y-wc)/fc))^(-1) + (1+exp(2(y+wc)/fc))^(-1) );\n    b = max(bx(x) + by(y), -720.0);\n    return b;\nend","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Let's take a look at this bed. First we define the grid sizes and build some arrays, so we can plot. We'll use a high resolution to get a nice plot:","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"dx = 1.e3;\ndy = 1.e3;\nnx = round(Int, 640*1e3/dx);\nny = round(Int, 80*1e3/dx);\nxx=[i*dx for i=1:nx, j=1:ny];\nyy=[j*dy for i=1:nx, j=1:ny] .- 42000;\nx = xx[:,1];\ny = yy[1,:];\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Now we can plot","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"plt =  Plots.heatmap(x/1e3, y/1e3, mismip_plus_bed.(xx,yy)',\n                    xlabel = \"x (km)\",\n                    ylabel = \"y (km)\",\n                    colorbar_title = \"bed depth (m)\")\nplot!(size = (800,400))","category":"page"},{"location":"generated/overdeepened_bed.html#Boundary-Conditions","page":"Two-dimensional flow with overdeepened bed","title":"Boundary Conditions","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"The MISMIP+ experiment specifies no slip (zero velocity in both directions) boundary conditions at x = 0, and free-slip boundary conditions (zero velocity in the direction normal to the walls) at the lateral boundaries at y = 0km and y = 84km. First, let's redefine the grid size to be lower resolution (to make the later simulations quicker)","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"dx = 4.e3;\ndy = 4.e3;\nnx = round(Int, 640*1e3/dx);\nny = round(Int, 80*1e3/dx);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Velocity boundary conditions are controlled by specifying zeros in appropriate entries in arrays, which are then passed to the grid:","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"u_iszero = falses(nx+1,ny); #build x-direction velocity boundary condition matrix with no zero boundary conditions anywhere\nu_iszero[1,:].=true;        #set the x-direction velocity to zero at x = 0.\nv_iszero=falses(nx,ny+1);   #build x-direction velocity boundary condition matrix with no zero boundary conditions anywhere\nv_iszero[:,1].=true;        #set the y-direction velocity to zero at y = 0 (free slip)\nv_iszero[:,end].=true;       #set the y-direction velocity to zero at y = 84km (free slip)\nv_iszero[1,:].=true;         #set the y-direction velocity to zero at x = 0km (no slip in combination with u_iszero)\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Now we build the grid as usual, passing the arrays we just constructed via optional arguments.","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"grid = Grid(nx = nx,\n            ny = ny,\n            dx = dx,\n            dy = dy,\n            u_iszero = u_iszero,\n            v_iszero = v_iszero);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html#Solver-Parameters","page":"Two-dimensional flow with overdeepened bed","title":"Solver Parameters","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"We're interested in the steady state reached at late times, rather than the solution along the way. We don't need to get the velocity right along the way, just have it correct eventually. We therefore set the number of iterations in the velocity solve to be small: at each timestep, the solver just does a small number of iterations, and the velocity is only approximate. But, since we do a lot of iterations getting to steady state, the velocity gets to the right thing eventually. This number, and other parameters relating to how the equations are solved, are set via a SolverParams object:","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"solver_params = SolverParams(maxiter_picard = 1);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Explicitly, we set the number of iterations (formally, Picard iterations) to be as small as possible, i.e. one iteration.","category":"page"},{"location":"generated/overdeepened_bed.html#Make-the-model","page":"Two-dimensional flow with overdeepened bed","title":"Make the model","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Now we have our grid, bed, and solver parameters, we just need to set the appropriate initial conditions and physical parameters for MISMIP+, and then we can build our model. In MISMIP+, the initial condition specifies 100m thick ice everywhere","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"initial_conditions = InitialConditions(initial_thickness = 100 .* ones(nx,ny));\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"And the accumulation rate is set to 0.3m/a (all other defaults in WAVI are chosen according to the values in MISMIP+)","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"params = Params( accumulation_rate = 0.3);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Now let's make our model! Note that we use the functional form of the bed (the array we plotted earlier has higher resolution than our model has)","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"model = Model(grid = grid,\n            bed_elevation = mismip_plus_bed,\n            initial_conditions = initial_conditions,\n            params = params,\n            solver_params = solver_params);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html#Assembling-the-Simulation","page":"Two-dimensional flow with overdeepened bed","title":"Assembling the Simulation","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"To get to steady state, we need to run our simulation for a good chunk of time, on the order of 10s of 1000s of years. We'll run for 10000 years, with a timestep of half a year:","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"timestepping_params = TimesteppingParams(dt = 0.5,\n                                        end_time = 100.,);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"NB!! We have to specify the end time as 10000. (a float number) rather than 10000 (an integer) because WAVI.jl expects the same type for the timestep dt and the end time end_time.","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"We'll output the solution along the way, and use this to convince ourselves later than we are in steady state. First let's make a directory to store the output","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"folder = joinpath(@__DIR__, \"overdeepened_bed\");\nisdir(folder) && rm(folder, force = true, recursive = true);\nmkdir(folder) ;\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Then define our output parameters. We'll output the thickness and grounded fraction every 200 years, and set the zip_format keyword argument to zip the output files.","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"output_params = OutputParams(outputs = (h = model.fields.gh.h,grfrac = model.fields.gh.grounded_fraction),\n                            output_freq = 10.,\n                            output_path = folder,\n                            zip_format = \"nc\");\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Now we assemble our simulation, taking in the model, output parameters and timestepping_params:","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"simulation = Simulation(model = model, timestepping_params = timestepping_params, output_params = output_params);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html#Timestepping","page":"Two-dimensional flow with overdeepened bed","title":"Timestepping","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Now all that's left to do is run our simulation! This is a long simulation and might take a while (~10 mins on my laptop)","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"run_simulation!(simulation);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html#Visualization","page":"Two-dimensional flow with overdeepened bed","title":"Visualization","text":"","category":"section"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Let's have a look at the steady state thickness:","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Plots.heatmap(simulation.model.grid.xxh[:,1]/1e3, simulation.model.grid.yyh[1,:]/1e3, simulation.model.fields.gh.h',\n                xlabel = \"x (km)\",\n                ylabel = \"y (km)\",\n                colorbar_title = \"ice thickness (m)\")","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"And add the grounding line, which is where the grounded fraction transitions between 0 and 1 (grounded_fraction takes the value 1 at fully grounded grid points and 0 at fully floating grid points.) Our choice of 0.5 is somewhat arbitrary here – any value between 0 and 1 will do!","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Plots.contour!(simulation.model.grid.xxh[:,1]/1e3,\n            simulation.model.grid.yyh[1,:]/1e3,\n            simulation.model.fields.gh.grounded_fraction',\n            fill = false,\n            levels = [0.5,0.5],\n            linecolor = :blue,\n            linewidth = 2)\nplot!(size = (1000,550))","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"You can see, by comparing with the plot of the bed earlier, that the grounding line sits on an overdeepened section of the bed!","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"Finally, let's check that it's in steady state, by looking at the evolution of the volume above floatation:","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"filename = joinpath(@__DIR__, \"overdeepened_bed\", \"outfile.nc\");\nh = ncread(filename, \"h\");\ngrfrac = ncread(filename, \"grfrac\");\ntime = ncread(filename, \"TIME\");\nvaf = sum(sum(h .* grfrac .* dx .*dy,dims = 1),dims = 2); #volume of ice above floatation\nPlots.plot(time, vaf[1,1,:]/1e9,\n             marker = true,\n             label = :none,\n             xlabel = \"time\",\n             ylabel = \"volume above floatation (km^3)\",\n             framestyle = :box)","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"The volume above floatation reaches a plateau, suggesting that we have reached a steady state. Finally, we clear up the files we just outputted","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"rm(folder, force = true, recursive = true);\nnothing #hide","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"","category":"page"},{"location":"generated/overdeepened_bed.html","page":"Two-dimensional flow with overdeepened bed","title":"Two-dimensional flow with overdeepened bed","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"EditURL = \"<unknown>/examples/planar_one_dimensional_flow.jl\"","category":"page"},{"location":"generated/planar_one_dimensional_flow.html#Planar-One-Dimensional-Flow","page":"One-dimensional planar flow","title":"Planar One-Dimensional Flow","text":"","category":"section"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"This a WAVI.jl's simplest example: flow down a flat plane in one horizontal dimension. This example demonstrates","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"How to load WAVI.jl.\nHow to instantiate an WAVI.jl model.\nHow to create simple WAVI.jl output.\nHow to time-step a model forward.\nHow to look at results.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html#Install-dependencies","page":"One-dimensional planar flow","title":"Install dependencies","text":"","category":"section"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"using Pkg\npkg\"add WAVI, Plots\"","category":"page"},{"location":"generated/planar_one_dimensional_flow.html#Using-WAVI.jl","page":"One-dimensional planar flow","title":"Using WAVI.jl","text":"","category":"section"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"using WAVI, Plots","category":"page"},{"location":"generated/planar_one_dimensional_flow.html#Instantiating-and-configuring-a-model","page":"One-dimensional planar flow","title":"Instantiating and configuring a model","text":"","category":"section"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"We first build a WAVI model, by passing it a grid, information about the problem we would like to solve.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Below, we build a grid with 300 grid points in the x direction. We use 2 grid points in the y direction (the minimum number of grid points in any dimension). This grid has a resolution of 12km.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"grid = Grid(nx = 300, ny = 2, dx = 12000.0, dy = 12000.0);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Next, we write a function which defines the WAVI.jl accepts both functions and arrays (of the same size as the grid) as bed inputs, but here we'll use a function for simplicity","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"function bed_elevation(x,y)\n    B = 720 - 778.5 * x ./ (750e3);\n    return B;\nend","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"This bed drops a height of 778.5m in every 750km, which is a typical scale for an ice sheet in Antarctica.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Next we specify physical parameters via a Params object. In this case, we set the accumulation rate (the net snowfall).","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"params = Params(accumulation_rate = 0.3);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Let's also set the thickness of the ice to be 300m everywhere, to start with. Initial conditions are set via InitialConditions objects","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"initial_conditions = InitialConditions(initial_thickness = 300. .* ones(grid.nx, grid.ny));\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Now we are ready to build a Model by assembling these pieces:","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"model = Model(grid = grid, bed_elevation = bed_elevation, params = params);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html#Simple-model-visualization","page":"One-dimensional planar flow","title":"Simple model visualization","text":"","category":"section"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Before we can vizualize anything, we need to update the model so that velocities are appropriate for this particular ice thickness. We do this with the update_state! function:","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"update_state!(model)","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Now let's plot the ice profile and ice velocity, starting with the bed","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"ice_plot = plot(model.grid.xxh[:,1]/1e3, model.fields.gh.b[:,1],\n                linewidth = 2,\n                linecolor = :brown,\n                label = \"bed\",\n                xlabel = \"x (km)\",\n                ylabel = \"z (m)\");\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Now add the ice surface","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"plot!(ice_plot, model.grid.xxh[:,1]/1e3, model.fields.gh.s[:,1],\n                linewidth = 2,\n                linecolor = :blue,\n                label = \"ice surface\");\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"And finally the ice base","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"plot!(ice_plot, model.grid.xxh[:,1]/1e3, model.fields.gh.s[:,1] .- model.fields.gh.h[:,1],\n                linewidth = 2,\n                linecolor = :red,\n                label = \"ice base\");\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"We see that the ice shelf goes afloat when the ice base is approximately 270m below sea level: 270m is the product of the ratio of the densities of ice (about 900 km/m^3) and ocean (about 1000 kg/m^3) with the ice thickness (300m).","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Lets also look at the velocity in the ice","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"vel_plot = plot(model.grid.xxh[:,1]/1e3, model.fields.gh.u[:,1],\n                linewidth = 2,\n                label = \"ice velocity\",\n                xlabel = \"x (km)\",\n                ylabel = \"ice velocity (m/yr)\");\n\np = Plots.plot(ice_plot,vel_plot, layout  = (2,1))\n#display(p)","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Ice velocities are very small (but non-zero) in the grounded ice, where friction between the ice and the bed restrains the flow. In the shelf, where there is no basal friction, velocities increase linearly to a maximum of 250 m/yr at the downstream end of the shelf.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html#Running-a-Simulation","page":"One-dimensional planar flow","title":"Running a Simulation","text":"","category":"section"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Now, let's think about advancing time. To do so, we set up a simulation, which time-steps the model forward and manages output.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"A TimesteppingParams object controls parameters related to timestepping. Let's set the model to run for 1000 years with a timestep of 0.5 years:","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"timestepping_params = TimesteppingParams(dt = 0.5, end_time = 10000.);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Now we can build the Simulation object and then run it!","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"simulation = Simulation(model = model, timestepping_params = timestepping_params);\nrun_simulation!(simulation);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Our simulation ran: simulation holds all the information about the state at time 100 years.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html#Outputting-the-solution","page":"One-dimensional planar flow","title":"Outputting the solution","text":"","category":"section"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Our simulation ran successfully, but we don't have any information about what happened. We get around this by outputting the solution regularly. First, make a clean folder where solution files will go:","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"folder = joinpath(@__DIR__, \"planar_one_dimensional_flow\");\nisdir(folder) && rm(folder, force = true, recursive = true);\nmkdir(folder) ;\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"What and when to output is specified in WAVI.jl by an instance of an OutputtingParams objects. Let's set one up so that the ice thickness, (unchanging) bed, ice surface and ice velocity is output every 100 years:","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"output_params = OutputParams(outputs = (h = model.fields.gh.h,u = model.fields.gh.u, b = model.fields.gh.b,s = model.fields.gh.s),\n                            output_freq = 1000.,\n                            output_path = folder);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Note that the outputs keyword argument takes a named tuple, which points to the locations of fields that are to be outputted.","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Let's build a new simulation, which knows about the outputting...","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"simulation = Simulation(model = model, timestepping_params = timestepping_params, output_params = output_params);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"...and run it","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"run_simulation!(simulation);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html#Visualizing-the-results","page":"One-dimensional planar flow","title":"Visualizing the results","text":"","category":"section"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Let's look at how the shape of the ice sheet changes during the simulation. To do, we'll loop over the output files and put the thickness and surface info a matrix","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"files = [joinpath(folder, file) for file in readdir(folder) if endswith( joinpath(folder, file), \".jld2\") ] ;\nnout = length(files);\nh_out = zeros(simulation.model.grid.nx, nout);\nsurface_out = zeros(simulation.model.grid.nx, nout);\nbase_out = zeros(simulation.model.grid.nx, nout);\nt_out = zeros(1,nout);\n\nfor i = 1:nout\n    d = load(files[i]);\n    h_out[:,i] = d[\"h\"][:,1];\n    base_out[:,i] = d[\"s\"][:,1] .- d[\"h\"][:,1];\n    surface_out[:,i] = d[\"s\"][:,1];\n    t_out[i] = d[\"t\"];\nend","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Now lets make the plot","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"pl = Plots.plot(simulation.model.grid.xxh[:,1], simulation.model.fields.gh.b[:,1],\n                    linecolor = :brown,\n                    xlabel = \"x (km)\",\n                    ylabel = \"z (m)\",\n                    legend = :none)\nPlots.plot!(pl,simulation.model.grid.xxh[:,1], surface_out, legend = :none, linecolor = :blue)\nPlots.plot!(pl,simulation.model.grid.xxh[:,1], base_out, legend = :none, linecolor = :red)","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"Finally, we clear up the files we just outputted","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"rm(folder, force = true, recursive = true);\nnothing #hide","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"","category":"page"},{"location":"generated/planar_one_dimensional_flow.html","page":"One-dimensional planar flow","title":"One-dimensional planar flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"data_structure/melt_rate_models.html#Melt-Rates","page":"Melt Rate Models","title":"Melt Rates","text":"","category":"section"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"WAVI.jl has a number of community melt rate parametrizations/models (referred to here collectively as 'melt rates') implemented and ready to use. Details of the physics of these models can be found on the melt rate physics page. This page provides a description of how to endow ice sheet models with a melt rate model/parametrization, as well as the interface of each of those that are implemented in WAVI.jl.","category":"page"},{"location":"data_structure/melt_rate_models.html#Adding-a-Melt-Rate-to-a-WAVI.jl-Model","page":"Melt Rate Models","title":"Adding a Melt Rate to a WAVI.jl Model","text":"","category":"section"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"Melt rates is WAVI.jl are interfaced via MeltRate objects. To build an ice sheet model with a melt rate, simply build the appropriate MeltRate object and then pass it to the Model when the latter is constructed.","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"This is best demonstrated by example: we first build a simple ice sheet model on a 20 x 20 grid, with a bed that is 50 m below sea level:","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"grid = Grid(nx = 20, ny = 20)\r\nbed_elevation = 50.0 * ones(grid.nx, grid.ny)","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"We then build our melt rate model. Let consider a simple case in which the melt rate is assumed to depend quadratically on the thermal forcing:","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"melt_rate = QuadraticMeltRate();","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"Finally, build the ice sheet model and pass the melt rate model","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"model = Model(grid = grid, bed_elevation = bed_elevation, melt_rate = melt_rate)","category":"page"},{"location":"data_structure/melt_rate_models.html#Analytic-Melt-Rate-Parametrizations","page":"Melt Rate Models","title":"Analytic Melt Rate Parametrizations","text":"","category":"section"},{"location":"data_structure/melt_rate_models.html#Input-File-Melt-Rates","page":"Melt Rate Models","title":"Input File Melt Rates","text":"","category":"section"},{"location":"data_structure/melt_rate_models.html#Quadratic-Melt-Rate","page":"Melt Rate Models","title":"Quadratic Melt Rate","text":"","category":"section"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"A QuadraticMeltModel – the melt rate used to implement the quadratic temperature melt rate parametrization is constructed using the QuadraticMeltModel(<kwargs>) constructor. ","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"A QuadraticMeltModel accepts the following keyword arguments:","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"h (required): array of ice thickness values at grid points\nmelt_partial_cell (default: false): specify whether to apply melt to partially floating cells or not.\nlambda_1 (default: -0.057): liquidus slope\nlambda_2 (default: 0.0832): liquidus intercept\nlambda_3 (default: 7.59e-4): liquidus pressure coefficient.\ngamma_T (default 99.32e-5): heat exchange velocity. Note that gamma_T is typically used as a tuning parameter, the default value is the tuned value from L Favier, N C Jourdain, A Jenkins, N Merino, G Durand, O Gagliardini, F Gillet-Chaulet, P Mathiot (2019).\nL (default 3.35e-5): latent heat of fusion\nrho_s (default 1028.0): sea water density\nrho_i (default 918.0): ice density\nc_p (default 3974.0): specific heat capacity of ocean\nS_0: far-field practical salinity profile (units: psu), passed to the constructor as a function of depth. The default is the 'warm0' profile used in L Favier, N C Jourdain, A Jenkins, N Merino, G Durand, O Gagliardini, F Gillet-Chaulet, P Mathiot (2019).\nT_0: far-field potential temperature profile (units: ^circC), passed to the constructor as a function of depth. The default is the 'warm0' profile used in L Favier, N C Jourdain, A Jenkins, N Merino, G Durand, O Gagliardini, F Gillet-Chaulet, P Mathiot (2019).","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"Ambient temperature and salinity profiles are passed to PlumeEmulator objects via the Ta and Sa keyword arguments, respectively. These must be passed as single valued functions of depth (i.e. temporal dependence in the ambient conditions is not yet supported). Ta and Sa default to the warm ambient profiles used in ISOMIP experiments (referred to as 'warm0' therein), with a lower layer of temperature 1.2∘C and salinity 34.6PSU separated from an upper layer of temperature -1∘C and salinity 33.8PSU by a pycnocline of thickness 400m, which begins at a depth of 700m below sea level.","category":"page"},{"location":"data_structure/melt_rate_models.html#Plume-Emulator-Melt-Rates","page":"Melt Rate Models","title":"Plume Emulator Melt Rates","text":"","category":"section"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"The plume model emulator of Lazeroms2018 is implemented via a PlumeEmulator object. Parameters used in plume model emulator melt rates are specified by keyword arguments passed to PlumeEmulator objects; these summarized in the following table:","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"Keyword Argument Description Units Default Value\nα Calibration coefficient Dimensionless 0.73\nλ1 Liquidus slope ∘C -0.057\nλ2 Liquidus intercept ∘C 0.0832\nλ3 Liquidus pressure coefficient ∘C/m 7.59e-4\nE0 Entrainment coefficient Dimensionless 3.6e-2\nCd Drag coefficient Dimensionless 2.5e-3\nΓ_TS Combination Stanton number Dimensionless 0.0118\nL Latent heat of ice fusion J/kg 3.35e5\nc Water specific heat capacity J/kg/∘C 3.974e3\nβs Haline contraction coefficient 1/PSU 7.86e-4\nβt Thermal expansion coefficient 1/∘C 3.87e-5\ng Gravitational acceleration m/s^2 9.81\nρi Ice density kg/m^3 918.0\nρw Water density kg/m^3 1028.0","category":"page"},{"location":"data_structure/melt_rate_models.html","page":"Melt Rate Models","title":"Melt Rate Models","text":"Ambient temperature and salinity profiles are passed to PlumeEmulator objects via the Ta and Sa keyword arguments, respectively. These must be passed as single valued functions of depth (i.e. temporal dependence in the ambient conditions is not yet supported). Ta and Sa default to the warm ambient profiles used in ISOMIP experiments (referred to as 'warm0' therein), with a lower layer of temperature 1.2∘C and salinity 34.6PSU separated from an upper layer of temperature -1∘C and salinity 33.8PSU by a pycnocline of thickness 400m, which begins at a depth of 700m below sea level.","category":"page"},{"location":"data_structure/melt_rate_models.html#PICO-Melt-Rate-Parametrization","page":"Melt Rate Models","title":"PICO Melt Rate Parametrization","text":"","category":"section"},{"location":"data_structure/melt_rate_models.html#PICOp-Melt-Rate-Parametrization","page":"Melt Rate Models","title":"PICOp Melt Rate Parametrization","text":"","category":"section"},{"location":"index.html#WAVI.jl-documentation","page":"Home","title":"WAVI.jl documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"WAVI.jl is an ice sheet model for everyone.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It is fast and detailed enough for use in research, yet friendly enough for students and first time programmers.","category":"page"},{"location":"mitgcm_coupling.html#MITgcm-coupling","page":"MITgcm coupling","title":"MITgcm coupling","text":"","category":"section"},{"location":"mitgcm_coupling.html","page":"MITgcm coupling","title":"MITgcm coupling","text":"MITgcm coupling with WAVI is an experimental feature. Check back soon for more info!","category":"page"}]
}
